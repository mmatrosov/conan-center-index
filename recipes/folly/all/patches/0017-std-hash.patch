https://github.com/facebook/folly/pull/1587
diff --git a/folly/Uri-inl.h b/folly/Uri-inl.h
index bd286f525..118c3bb63 100644
--- a/folly/Uri-inl.h
+++ b/folly/Uri-inl.h
@@ -86,8 +86,7 @@ namespace std {
 template <>
 struct hash<folly::Uri> {
   std::size_t operator()(const folly::Uri& k) const {
-    return std::hash<folly::uri_detail::UriTuple>{}(
-        folly::uri_detail::as_tuple(k));
+    return folly::compute_std_tuple_hash(folly::uri_detail::as_tuple(k));
   }
 };
 
diff --git a/folly/dynamic.cpp b/folly/dynamic.cpp
index f145e2a46..be0c3e8be 100644
--- a/folly/dynamic.cpp
+++ b/folly/dynamic.cpp
@@ -289,7 +289,7 @@ std::size_t dynamic::hash() const {
       // Accumulate using addition instead of using hash_range (as in the ARRAY
       // case), as we need a commutative hash operation since unordered_map's
       // iteration order is unspecified.
-      auto h = std::hash<std::pair<dynamic const, dynamic>>{};
+      auto h = folly::std_pair_hash{};
       return std::accumulate(
           items().begin(),
           items().end(),
diff --git a/folly/experimental/JSONSchema.cpp b/folly/experimental/JSONSchema.cpp
index 245754858..924b1e565 100644
--- a/folly/experimental/JSONSchema.cpp
+++ b/folly/experimental/JSONSchema.cpp
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include <folly/hash/Hash.h>
 #include <folly/experimental/JSONSchema.h>
 
 #include <boost/algorithm/string/replace.hpp>
@@ -85,7 +86,7 @@ struct ValidationContext {
   }
 
  private:
-  std::unordered_set<std::pair<const IValidator*, const dynamic*>> seen;
+  std::unordered_set<std::pair<const IValidator*, const dynamic*>, folly::std_pair_hash> seen;
 };
 
 /**
diff --git a/folly/fibers/FiberManager.cpp b/folly/fibers/FiberManager.cpp
index a5b12fb70..25bdf6a0b 100644
--- a/folly/fibers/FiberManager.cpp
+++ b/folly/fibers/FiberManager.cpp
@@ -15,6 +15,7 @@
  */
 
 #include <folly/fibers/FiberManagerInternal.h>
+#include <folly/hash/Hash.h>
 
 #include <csignal>
 
@@ -73,7 +74,7 @@ namespace std {
 template <>
 struct hash<folly::fibers::FiberManager::Options> {
   ssize_t operator()(const folly::fibers::FiberManager::Options& opts) const {
-    return hash<decltype(opts.hash())>()(opts.hash());
+    return folly::compute_std_tuple_hash(opts.hash());
   }
 };
 } // namespace std
diff --git a/folly/fibers/GuardPageAllocator.cpp b/folly/fibers/GuardPageAllocator.cpp
index 7ab23e400..fe088fd62 100644
--- a/folly/fibers/GuardPageAllocator.cpp
+++ b/folly/fibers/GuardPageAllocator.cpp
@@ -15,6 +15,7 @@
  */
 
 #include <folly/fibers/GuardPageAllocator.h>
+#include <folly/hash/Hash.h>
 
 #ifndef _WIN32
 #include <dlfcn.h>
@@ -186,10 +187,11 @@ class StackCache {
   /**
    * For each [b, e) range in this set, the bytes in the range were mprotected.
    */
-  static folly::Synchronized<std::unordered_set<std::pair<intptr_t, intptr_t>>>&
+  static folly::Synchronized<
+      std::unordered_set<std::pair<intptr_t, intptr_t>, folly::std_pair_hash>>&
   protectedRanges() {
     static auto instance = new folly::Synchronized<
-        std::unordered_set<std::pair<intptr_t, intptr_t>>>();
+        std::unordered_set<std::pair<intptr_t, intptr_t>, folly::std_pair_hash>>();
     return *instance;
   }
 };
diff --git a/folly/hash/Hash.h b/folly/hash/Hash.h
index ede79429f..01008704e 100644
--- a/folly/hash/Hash.h
+++ b/folly/hash/Hash.h
@@ -754,16 +754,12 @@ struct TupleHasher<0, Ts...> {
   }
 };
 
-} // namespace folly
-
-// Custom hash functions.
-namespace std {
 // Hash function for pairs. Requires default hash functions for both
 // items in the pair.
-template <typename T1, typename T2>
-struct hash<std::pair<T1, T2>> {
+struct std_pair_hash {
   using folly_is_avalanching = std::true_type;
 
+  template <typename T1, typename T2>
   size_t operator()(const std::pair<T1, T2>& x) const {
     return folly::hash::hash_combine(x.first, x.second);
   }
@@ -771,7 +767,7 @@ struct hash<std::pair<T1, T2>> {
 
 // Hash function for tuples. Requires default hash functions for all types.
 template <typename... Ts>
-struct hash<std::tuple<Ts...>> {
+struct std_tuple_hash {
  private:
   using FirstT = std::decay_t<std::tuple_element_t<0, std::tuple<Ts..., bool>>>;
 
@@ -789,9 +785,11 @@ struct hash<std::tuple<Ts...>> {
     return hasher(key);
   }
 };
-} // namespace std
 
-namespace folly {
+template <typename... Ts>
+size_t compute_std_tuple_hash(std::tuple<Ts...> const& key) {
+  return std_tuple_hash<Ts...>{}(key);
+}
 
 // std::hash<std::string> is avalanching on libstdc++-v3 (code checked),
 // libc++ (code checked), and MSVC (based on online information).
diff --git a/folly/hash/test/HashTest.cpp b/folly/hash/test/HashTest.cpp
index e1b2c9f4a..f0579538a 100644
--- a/folly/hash/test/HashTest.cpp
+++ b/folly/hash/test/HashTest.cpp
@@ -761,26 +761,26 @@ static_assert(
 // these come from folly/hash/Hash.h
 static_assert(
     folly::IsAvalanchingHasher<
-        std::hash<std::pair<int, int>>,
+        folly::std_pair_hash<int, int>,
         std::pair<int, int>>::value,
     "");
 static_assert(
-    !folly::IsAvalanchingHasher<std::hash<std::tuple<int>>, std::tuple<int>>::
+    !folly::IsAvalanchingHasher<folly::std_tuple_hash<int>, std::tuple<int>>::
         value,
     "");
 static_assert(
     folly::IsAvalanchingHasher<
-        std::hash<std::tuple<std::string>>,
+        folly::std_tuple_hash<std::string>,
         std::tuple<std::string>>::value,
     "");
 static_assert(
     folly::IsAvalanchingHasher<
-        std::hash<std::tuple<int, int>>,
+        folly::std_tuple_hash<int, int>,
         std::tuple<int, int>>::value,
     "");
 static_assert(
     folly::IsAvalanchingHasher<
-        std::hash<std::tuple<int, int, int>>,
+        folly::std_tuple_hash<int, int, int>,
         std::tuple<int, int, int>>::value,
     "");
 
@@ -950,12 +950,12 @@ void verifyAvalanching(T initialValue, F const& advance) {
 } // namespace
 
 TEST(Traits, stdHashPairAvalances) {
-  verifyAvalanching<std::hash<std::pair<int, int>>>(
+  verifyAvalanching<folly::std_pair_hash<int, int>>(
       std::make_pair(0, 0), [](std::pair<int, int>& v) { v.first++; });
 }
 
 TEST(Traits, stdHashTuple2Avalances) {
-  verifyAvalanching<std::hash<std::tuple<int, int>>>(
+  verifyAvalanching<folly::std_tuple_hash<int, int>>(
       std::make_tuple(0, 0),
       [](std::tuple<int, int>& v) { std::get<0>(v) += 1; });
 }
